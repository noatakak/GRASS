{
    "directed": true,
    "multigraph": false,
    "graph": {},
    "nodes": [
        {
            "name": "craftItem",
            "weight": {
                "depth": 0,
                "successors": 0,
                "failures": 0
            },
            "knowledge": "// Craft 8 oak_planks from 2 oak_log (do the recipe 2 times): craftItem(bot, \"oak_planks\", 2);\n// You must place a crafting table before calling this function\nasync function craftItem(bot, name, count = 1) {\n    const item = mcData.itemsByName[name];\n    const craftingTable = bot.findBlock({\n        matching: mcData.blocksByName.crafting_table.id,\n        maxDistance: 32,\n    });\n    await bot.pathfinder.goto(\n        new GoalLookAtBlock(craftingTable.position, bot.world)\n    );\n    const recipe = bot.recipesFor(item.id, null, 1, craftingTable)[0];\n    await bot.craft(recipe, count, craftingTable);\n}\n",
            "requirements": {},
            "file_path": "grass\\control_primitives\\craftItem.js",
            "id": "craftItem"
        },
        {
            "name": "exploreUntil",
            "weight": {
                "depth": 0,
                "successors": 0,
                "failures": 0
            },
            "knowledge": "/*\nExplore until find an iron_ore, use Vec3(0, -1, 0) because iron ores are usually underground\nawait exploreUntil(bot, new Vec3(0, -1, 0), 60, () => {\n    const iron_ore = bot.findBlock({\n        matching: mcData.blocksByName[\"iron_ore\"].id,\n        maxDistance: 32,\n    });\n    return iron_ore;\n});\n\nExplore until find a pig, use Vec3(1, 0, 1) because pigs are usually on the surface\nlet pig = await exploreUntil(bot, new Vec3(1, 0, 1), 60, () => {\n    const pig = bot.nearestEntity((entity) => {\n        return (\n            entity.name === \"pig\" &&\n            entity.position.distanceTo(bot.entity.position) < 32\n        );\n    });\n    return pig;\n});\n*/\nasync function exploreUntil(bot, direction, maxTime = 60, callback) {\n    /*\n    Implementation of this function is omitted.\n    direction: Vec3, can only contain value of -1, 0 or 1\n    maxTime: number, the max time for exploration\n    callback: function, early stop condition, will be called each second, exploration will stop if return value is not null\n\n    Return: null if explore timeout, otherwise return the return value of callback\n    */\n}\n",
            "requirements": {},
            "file_path": "grass\\control_primitives\\exploreUntil.js",
            "id": "exploreUntil"
        },
        {
            "name": "killMob",
            "weight": {
                "depth": 0,
                "successors": 0,
                "failures": 0
            },
            "knowledge": "// Kill a pig and collect the dropped item: killMob(bot, \"pig\", 300);\nasync function killMob(bot, mobName, timeout = 300) {\n    const entity = bot.nearestEntity(\n        (entity) =>\n            entity.name === mobName &&\n            entity.position.distanceTo(bot.entity.position) < 32\n    );\n    await bot.pvp.attack(entity);\n    await bot.pathfinder.goto(\n        new GoalBlock(entity.position.x, entity.position.y, entity.position.z)\n    );\n}\n",
            "requirements": {},
            "file_path": "grass\\control_primitives\\killMob.js",
            "id": "killMob"
        },
        {
            "name": "mineBlock",
            "weight": {
                "depth": 0,
                "successors": 0,
                "failures": 0
            },
            "knowledge": "// Mine 3 cobblestone: mineBlock(bot, \"stone\", 3);\nasync function mineBlock(bot, name, count = 1) {\n    const blocks = bot.findBlocks({\n        matching: (block) => {\n            return block.name === name;\n        },\n        maxDistance: 32,\n        count: count,\n    });\n    const targets = [];\n    for (let i = 0; i < Math.min(blocks.length, count); i++) {\n        targets.push(bot.blockAt(blocks[i]));\n    }\n    await bot.collectBlock.collect(targets, { ignoreNoPath: true });\n}\n",
            "requirements": {},
            "file_path": "grass\\control_primitives\\mineBlock.js",
            "id": "mineBlock"
        },
        {
            "name": "mineflayer",
            "weight": {
                "depth": 0,
                "successors": 0,
                "failures": 0
            },
            "knowledge": "await bot.pathfinder.goto(goal); // A very useful function. This function may change your main-hand equipment.\n// Following are some Goals you can use:\nnew GoalNear(x, y, z, range); // Move the bot to a block within the specified range of the specified block. `x`, `y`, `z`, and `range` are `number`\nnew GoalXZ(x, z); // Useful for long-range goals that don't have a specific Y level. `x` and `z` are `number`\nnew GoalGetToBlock(x, y, z); // Not get into the block, but get directly adjacent to it. Useful for fishing, farming, filling bucket, and beds. `x`, `y`, and `z` are `number`\nnew GoalFollow(entity, range); // Follow the specified entity within the specified range. `entity` is `Entity`, `range` is `number`\nnew GoalPlaceBlock(position, bot.world, {}); // Position the bot in order to place a block. `position` is `Vec3`\nnew GoalLookAtBlock(position, bot.world, {}); // Path into a position where a blockface of the block at position is visible. `position` is `Vec3`\n\n// These are other Mineflayer functions you can use:\nbot.isABed(bedBlock); // Return true if `bedBlock` is a bed\nbot.blockAt(position); // Return the block at `position`. `position` is `Vec3`\n\n// These are other Mineflayer async functions you can use:\nawait bot.equip(item, destination); // Equip the item in the specified destination. `item` is `Item`, `destination` can only be \"hand\", \"head\", \"torso\", \"legs\", \"feet\", \"off-hand\"\nawait bot.consume(); // Consume the item in the bot's hand. You must equip the item to consume first. Useful for eating food, drinking potions, etc.\nawait bot.fish(); // Let bot fish. Before calling this function, you must first get to a water block and then equip a fishing rod. The bot will automatically stop fishing when it catches a fish\nawait bot.sleep(bedBlock); // Sleep until sunrise. You must get to a bed block first\nawait bot.activateBlock(block); // This is the same as right-clicking a block in the game. Useful for buttons, doors, etc. You must get to the block first\nawait bot.lookAt(position); // Look at the specified position. You must go near the position before you look at it. To fill bucket with water, you must lookAt first. `position` is `Vec3`\nawait bot.activateItem(); // This is the same as right-clicking to use the item in the bot's hand. Useful for using buckets, etc. You must equip the item to activate first\nawait bot.useOn(entity); // This is the same as right-clicking an entity in the game. Useful for shearing sheep, equipping harnesses, etc. You must get to the entity first\n",
            "requirements": {},
            "file_path": "grass\\control_primitives_context\\mineflayer.js",
            "id": "mineflayer"
        },
        {
            "name": "placeItem",
            "weight": {
                "depth": 0,
                "successors": 0,
                "failures": 0
            },
            "knowledge": "// Place a crafting_table near the player, Vec3(1, 0, 0) is just an example, you shouldn't always use that: placeItem(bot, \"crafting_table\", bot.entity.position.offset(1, 0, 0));\nasync function placeItem(bot, name, position) {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name].id);\n    // find a reference block\n    const faceVectors = [\n        new Vec3(0, 1, 0),\n        new Vec3(0, -1, 0),\n        new Vec3(1, 0, 0),\n        new Vec3(-1, 0, 0),\n        new Vec3(0, 0, 1),\n        new Vec3(0, 0, -1),\n    ];\n    let referenceBlock = null;\n    let faceVector = null;\n    for (const vector of faceVectors) {\n        const block = bot.blockAt(position.minus(vector));\n        if (block?.name !== \"air\") {\n            referenceBlock = block;\n            faceVector = vector;\n            break;\n        }\n    }\n    // You must first go to the block position you want to place\n    await bot.pathfinder.goto(new GoalPlaceBlock(position, bot.world, {}));\n    // You must equip the item right before calling placeBlock\n    await bot.equip(item, \"hand\");\n    await bot.placeBlock(referenceBlock, faceVector);\n}\n",
            "requirements": {},
            "file_path": "grass\\control_primitives\\placeItem.js",
            "id": "placeItem"
        },
        {
            "name": "smeltItem",
            "weight": {
                "depth": 0,
                "successors": 0,
                "failures": 0
            },
            "knowledge": "// Smelt 1 raw_iron into 1 iron_ingot using 1 oak_planks as fuel: smeltItem(bot, \"raw_iron\", \"oak_planks\");\n// You must place a furnace before calling this function\nasync function smeltItem(bot, itemName, fuelName, count = 1) {\n    const item = mcData.itemsByName[itemName];\n    const fuel = mcData.itemsByName[fuelName];\n    const furnaceBlock = bot.findBlock({\n        matching: mcData.blocksByName.furnace.id,\n        maxDistance: 32,\n    });\n    await bot.pathfinder.goto(\n        new GoalLookAtBlock(furnaceBlock.position, bot.world)\n    );\n    const furnace = await bot.openFurnace(furnaceBlock);\n    for (let i = 0; i < count; i++) {\n        await furnace.putFuel(fuel.id, null, 1);\n        await furnace.putInput(item.id, null, 1);\n        // Wait 12 seconds for the furnace to smelt the item\n        await bot.waitForTicks(12 * 20);\n        await furnace.takeOutput();\n    }\n    await furnace.close();\n}\n",
            "requirements": {},
            "file_path": "grass\\control_primitives\\smeltItem.js",
            "id": "smeltItem"
        },
        {
            "name": "useChest",
            "weight": {
                "depth": 0,
                "successors": 0,
                "failures": 0
            },
            "knowledge": "// Get a torch from chest at (30, 65, 100): getItemFromChest(bot, new Vec3(30, 65, 100), {\"torch\": 1});\n// This function will work no matter how far the bot is from the chest.\nasync function getItemFromChest(bot, chestPosition, itemsToGet) {\n    await moveToChest(bot, chestPosition);\n    const chestBlock = bot.blockAt(chestPosition);\n    const chest = await bot.openContainer(chestBlock);\n    for (const name in itemsToGet) {\n        const itemByName = mcData.itemsByName[name];\n        const item = chest.findContainerItem(itemByName.id);\n        await chest.withdraw(item.type, null, itemsToGet[name]);\n    }\n    await closeChest(bot, chestBlock);\n}\n// Deposit a torch into chest at (30, 65, 100): depositItemIntoChest(bot, new Vec3(30, 65, 100), {\"torch\": 1});\n// This function will work no matter how far the bot is from the chest.\nasync function depositItemIntoChest(bot, chestPosition, itemsToDeposit) {\n    await moveToChest(bot, chestPosition);\n    const chestBlock = bot.blockAt(chestPosition);\n    const chest = await bot.openContainer(chestBlock);\n    for (const name in itemsToDeposit) {\n        const itemByName = mcData.itemsByName[name];\n        const item = bot.inventory.findInventoryItem(itemByName.id);\n        await chest.deposit(item.type, null, itemsToDeposit[name]);\n    }\n    await closeChest(bot, chestBlock);\n}\n// Check the items inside the chest at (30, 65, 100): checkItemInsideChest(bot, new Vec3(30, 65, 100));\n// You only need to call this function once without any action to finish task of checking items inside the chest.\nasync function checkItemInsideChest(bot, chestPosition) {\n    await moveToChest(bot, chestPosition);\n    const chestBlock = bot.blockAt(chestPosition);\n    await bot.openContainer(chestBlock);\n    // You must close the chest after opening it if you are asked to open a chest\n    await closeChest(bot, chestBlock);\n}\n",
            "requirements": {},
            "file_path": "grass\\control_primitives\\useChest.js",
            "id": "useChest"
        }
    ],
    "links": []
}